#' @title Calculate Body Weight Z-score for a given STUDYID from SQLite Database or `.xpt` Files
#'
#' @description
#' The `get_bw_score` function calculates the Body Weight (BW) Z-score for a specified STUDYID using data from a provided database or .xpt files.
#' It supports optional parameters to customize the analysis and offers the flexibility to return individual Z-score by `USUBJID` (unique subject identifier).
#'
#' @param studyid Character. STUDYID number. Defaults to `NULL`.
#'    Required for SQLite databases (`use_xpt_file = FALSE`).
#'    Must be `NULL` for `.xpt` files (`use_xpt_file = TRUE`).
#' @param path_db Character. Path to the SQLite database file or a folder containing `.xpt` files. Mandatory.
#' @param fake_study Logical. Whether the study data is generated by the `SENDsanitizer` package. Defaults to `FALSE`.
#' @param use_xpt_file Logical. Whether to retrieve study data from `.xpt` files instead of the SQLite database. Defaults to `FALSE`.
#' @param master_compiledata Optional, character \cr
#'   If `master_compiledata` is not supplied (i.e., `NULL`), the function will automatically call the `get_compile_data` function to calculate it.
#' @param return_individual_scores Optional, logical \cr
#'   If TRUE, the function returns individual scores for each domain by averaging the scores of all subjects/animals (`USUBJID`) in the study. Default is `FALSE`.
#' @param return_zscore_by_USUBJID Optional, logical \cr
#'    If `TRUE`, the function returns Z-scores for each animal/subject by `USUBJID`. Default is `FALSE`.
#'
#' @return
#' A `data.frame` containing the calculated BW Z-scores. The structure of the output depends on the provided parameters:
#' - If `return_individual_scores = TRUE`: Returns averaged Z-scores for each  domain per `studyid`.
#' - If `return_zscore_by_USUBJID = TRUE`: Returns Z-score for each animal/subject by `USUBJID` for each domain per `studyid`.
#' - Otherwise, a summarized BW score for the specified `studyid`.
#'
#' @examples
#' \dontrun{
#' # Example 1: Basic usage
#' get_bw_score(studyid = '1234123', path_db = 'path/to/database.db')
#'
#' # Example 2: Include individual scores
#' get_bw_score(studyid = '1234123', path_db = 'path/to/database.db', return_individual_scores = TRUE)
#'
#' # Example 3: Include z-scores by USUBJID
#' get_bw_score(studyid = '1234123', path_db = 'path/to/database.db', return_zscore_by_USUBJID = TRUE)
#' }
#'
#' @export
#' @importFrom RSQLite dbConnect
#' @importFrom RSQLite SQLite


get_bw_score <- function(studyid = NULL,
                         path_db,
                         fake_study = FALSE,
                         use_xpt_file = FALSE,
                         master_compiledata = NULL,
                         return_individual_scores = FALSE,
                         return_zscore_by_USUBJID = FALSE) {

  # Enforce mutual exclusivity: If both are TRUE, throw an error or handle it
  if (return_individual_scores && return_zscore_by_USUBJID) {
    stop("Error: Both 'return_individual_scores' and 'return_zscore_by_USUBJID' cannot be TRUE at the same time.")
  }

  studyid <- as.character(studyid)
  path <- path_db

  # Define a function to query the database by domain
  fetch_domain_data <- function(db_connection, domain_name, studyid) {
    domain_name <- toupper(domain_name)
    query_statement <- paste0('SELECT * FROM ', domain_name, " WHERE STUDYID = :x")
    query_result <- DBI::dbGetQuery(db_connection, statement = query_statement, params = list(x = studyid))
    query_result
  }

  get_csv_data <- function(csv_path, pattern) {
    csv_filename <- list.files(csv_path, pattern = pattern, ignore.case = TRUE)[1]
    csv_df <- read.csv(fs::path(csv_path, csv_filename))
    empty_name_cols <- which(colnames(csv_df) == "X")
    if (length(empty_name_cols) > 0) {
      csv_df <- csv_df[, -empty_name_cols]
    } else {
      csv_df <- csv_df # No empty named columns to remove
    }
    csv_df[is.na(csv_df)] <- ''
    csv_df <- mutate(csv_df, STUDYID = as.character(STUDYID))
    csv_df
  }

  if (use_xpt_file) {
    # Read data from .xpt files
    bw <- haven::read_xpt(fs::path(path, 'bw.xpt'))
  } else {
    # Read data from .csv files
    bw <- get_csv_data(path, 'bw\\.csv')
  }

  # Print the dimension of the data frames
  print("*********************************************************************************************************")
  print("*********************************************************************************************************")
  cat("The dimension of '.......bw...data...frame.......' is:--------", dim(bw)[1], "rows and", dim(bw)[2], "columns.\n")
  print("*********************************************************************************************************")
  print("*********************************************************************************************************")


# Check if both BWDY and VISITDY columns exist in the 'bw' data frame
if (!("BWDY" %in% colnames(bw)) && !("VISITDY" %in% colnames(bw))) {
  stop("Both 'BWDY' and 'VISITDY' columns are absent in the 'bw' data frame.")
} else if ("BWDY" %in% colnames(bw) && !("VISITDY" %in% colnames(bw))) {
  # If BWDY is present and VISITDY is absent, create VISITDY with the values of BWDY
  bw$VISITDY <- bw$BWDY
} else if (!("BWDY" %in% colnames(bw)) && "VISITDY" %in% colnames(bw)) {
  # If VISITDY is present and BWDY is absent, create BWDY with the values of VISITDY
  bw$BWDY <- bw$VISITDY
}
# If both are present, do nothing


  # Ensuring "BWSTRESN", "VISITDY", "BWDY" columns are numeric
  bw$BWSTRESN <- as.numeric(bw$BWSTRESN)
  bw$VISITDY <- as.numeric(bw$VISITDY)
  bw$BWDY <- as.numeric(bw$BWDY)


  #.................. "BodyWeight_zScore" .....calculation........
  #................... Initial BW weight calculation..............

    StudyInitialWeights <- data.frame("STUDYID" = NA,
                                      "USUBJID" = NA,
                                      "BWSTRESN" = NA,
                                      "VISITDY" = NA)

    # Initialize dataframe for unmatched USUBJIDs
    UnmatchedUSUBJIDs <- data.frame("USUBJID" = character(), stringsAsFactors = FALSE)


     if (TRUE){
      # Get unique USUBJIDs in the current study
      unique_subjids <- unique(bw$USUBJID)

      for (currentUSUBJID in unique_subjids) {

        # Initialize an empty dataframe for this subject
        SubjectInitialWeight <- data.frame()

        # Data (all rows) for the current USUBJID
        subj_data <- bw[which(bw$USUBJID == currentUSUBJID), ]

        # for any row if  VISITDY column data is empty replace it with the corresponding values from BWDY column
        subj_data <- subj_data %>% dplyr::mutate(VISITDY = ifelse(is.na(VISITDY) | VISITDY == "", BWDY, VISITDY))

        # 1. Check if VISITDY == 1 is present
        SubjectInitialWeight <- subj_data[subj_data$VISITDY == 1,
                                          c("STUDYID", "USUBJID", "BWSTRESN", "VISITDY")]


        # 2. If no initial weight with VISITDY == 1,  try VISITDY < 0
        if (nrow(SubjectInitialWeight) == 0) {
          negative_visits <- subj_data[subj_data$VISITDY < 0, ]
          if (nrow(negative_visits) > 0) {
            closest_row <- which.min(abs(negative_visits$VISITDY))
            SubjectInitialWeight <- negative_visits[closest_row, c("STUDYID", "USUBJID", "BWSTRESN", "VISITDY")]
          }
        }

        # 3. If no initial weight with VISITDY == 1 VISITDY < 0 , try 1<VISITDY<=5
        if (nrow(SubjectInitialWeight) == 0) {
          five_visitdy <- subj_data[subj_data$VISITDY > 1 & subj_data$VISITDY <= 5, ]

          if (nrow(five_visitdy) > 0) {
            # If there are rows where 1 < VISITDY <= 5, choose the one with the minimum VISITDY value
            closest_row_five <- which.min(five_visitdy$VISITDY)
            SubjectInitialWeight <- five_visitdy[closest_row_five, c("STUDYID", "USUBJID", "BWSTRESN", "VISITDY")]
          }
        }

        # 4. If no rows, if VISITDY  >5 , set BWSTRESN value 0
        if (nrow(SubjectInitialWeight) == 0) {
          null_visitdy_large_bw <- subj_data[subj_data$VISITDY > 5, ]

          if (nrow(null_visitdy_large_bw) > 0) {
            # Set BWSTRESN to 0 for the rows that meet the condition
            null_visitdy_large_bw$BWSTRESN <- 0

            # Choose the row with the minimum VISITDY value greater than 5
            closest_row_null_visitdy <- which.min(null_visitdy_large_bw$VISITDY)
            SubjectInitialWeight <- null_visitdy_large_bw[closest_row_null_visitdy, c("STUDYID", "USUBJID", "BWSTRESN", "VISITDY")]
          }
        }

        # If SubjectInitialWeight is still empty, add currentUSUBJID to UnmatchedUSUBJIDs
        if (nrow(SubjectInitialWeight) == 0) {
          UnmatchedUSUBJIDs <- rbind(UnmatchedUSUBJIDs, data.frame(USUBJID = currentUSUBJID, stringsAsFactors = FALSE))
        }
        # Store Values to "StudyInitialWeights" data frame
        StudyInitialWeights <- rbind(StudyInitialWeights,SubjectInitialWeight)
      }
   }

    # remove the first row (initialized with NAs)
    StudyInitialWeights <- StudyInitialWeights[-1, ]


    #Check for the presence of duplicate "USUBJID" in "StudyInitialWeights"

    # Check for any duplicate USUBJID
    duplicates_exist <- any(duplicated(StudyInitialWeights$USUBJID))

    # Output result
     if (duplicates_exist) {
        print("There are duplicate USUBJID values in StudyInitialWeights")
     } else {
       print("No duplicate USUBJID values found in StudyInitialWeights")
     }

    #  see the duplicate values
    if (duplicates_exist) {
      duplicate_usubjids <- StudyInitialWeights$USUBJID[duplicated(StudyInitialWeights$USUBJID)]
    }

    # Duplicate rows handling
    # Removing duplicates based on specific column(s)
    # only the first occurrence of each unique USUBJID will be kept, and subsequent duplicates will be removed
    StudyInitialWeights <- StudyInitialWeights[!duplicated(StudyInitialWeights$USUBJID), ]


    #.......................................................................
    # ..........Final day "StudyBodyWeights" calculation.....................

    #......(StudyBodyWeights)-(TERMBW)-(BoDY Weigt) calculation...............

    # Initialize "StudyBodyWeights" empty data frame
    StudyBodyWeights <- data.frame("STUDYID" = NA,
                                   "USUBJID" = NA,
                                   "BWTESTCD" = NA,
                                   "BWSTRESN" = NA,
                                   "VISITDY" = NA)

    # Initialize dataframe for unmatched USUBJIDs
    BodyWeights_UnmatchedUSUBJIDs <- data.frame("USUBJID" = character(),
                                                stringsAsFactors = FALSE)


    if(TRUE) {
      # Get unique USUBJIDs in the current study
      unique_bw_subjids <- unique(bw$USUBJID)

      for (current_bw_USUBJID in unique_bw_subjids) {

        # Initialize an empty dataframe for this subject
        SubjectBodyWeight <- data.frame()

        # Data (all rows) for the current USUBJID
        subj_bw_data <- bw[which(bw$USUBJID == current_bw_USUBJID), ]

        # for any row if  VISITDY column data is empty replace it with the corresponding values from BWDY column
        subj_bw_data <- subj_bw_data %>% dplyr::mutate(VISITDY = ifelse(is.na(VISITDY) | VISITDY == "", BWDY, VISITDY))


        # 1. Check if BWTESTCD == TERMBW is present
        SubjectBodyWeight <- subj_bw_data[subj_bw_data$BWTESTCD == "TERMBW",
                                          c("STUDYID", "USUBJID", "BWTESTCD","BWSTRESN", "VISITDY")]

        # If BWTESTCD == TERMBW not present,
        # 2. If no  BWTESTCD == TERMBW,try  VISITDY > 5"
        # should we do that ..............
        if (nrow(SubjectBodyWeight) == 0) {
          positive_bw_VISITDY <- subj_bw_data[subj_bw_data$VISITDY > 5 , ]

          if (nrow(positive_bw_VISITDY) > 0) {
            # choose the one with the maximum VISITDY value
            max_VISITDY <- which.max(positive_bw_VISITDY$VISITDY)
            SubjectBodyWeight <- positive_bw_VISITDY[max_VISITDY, c("STUDYID", "USUBJID", "BWTESTCD", "BWSTRESN", "VISITDY")] #, "BWNOMDY", "BWNOMLBL", "BWBLFL")]
          }
        }

        # If SubjectInitialWeight is still empty, add currentUSUBJID to UnmatchedUSUBJIDs
        if (nrow(SubjectBodyWeight) == 0) {
          BodyWeights_UnmatchedUSUBJIDs <- rbind(BodyWeights_UnmatchedUSUBJIDs, data.frame(USUBJID = current_bw_USUBJID, stringsAsFactors = FALSE))
        }

        # Store Values to "StudyBodyWeights" data frame
        StudyBodyWeights  <- rbind(StudyBodyWeights ,SubjectBodyWeight)
      }
    }

    # Remove the first row (initialized with NAs)
    StudyBodyWeights <- StudyBodyWeights[-1, ]


    #Check for the presence of duplicate "USUBJID" in "StudyBodyWeights"

    # Check for any duplicate USUBJID
    stbw_duplicates_exist <- any(duplicated(StudyBodyWeights$USUBJID))

    # Output result
     if (stbw_duplicates_exist) {
       print("There are duplicate USUBJID values in StudyBodyWeights")
     } else {
       print("No duplicate USUBJID values found in StudyBodyWeights")
     }

    # See the duplicate values
    if (stbw_duplicates_exist) {
      stbw_duplicate_usubjids <- StudyBodyWeights$USUBJID[duplicated(StudyBodyWeights$USUBJID)]
       print( stbw_duplicate_usubjids)
    }

    # Duplicate "StudyBodyWeights" rows handling

    # Removing duplicates based on specific column(s)
    # only the first occurrence of each unique USUBJID will be kept, and subsequent duplicates will be removed
    # StudyBodyWeights <- StudyBodyWeights[!duplicated(StudyBodyWeights$USUBJID), ]

    # number of unique USUBJID
    unique_StudyBodyWeights_USUBJID <- length(unique(StudyBodyWeights$USUBJID))

    #<><><><><><><><><><><><><><><><>... Remove TK animals and Recovery animals......<><><><><><>.............
    #<><><><><><><><> master_compiledata is free of TK animals and Recovery animals<><><><><><><><><><><><><><>

    if (is.null(master_compiledata)) {

      studyid <- if (use_xpt_file) NULL else studyid

      master_compiledata <- get_compile_data(studyid = studyid,
                                             path_db = path_db,
                                             fake_study = fake_study,
                                             use_xpt_file = use_xpt_file)
    }


    #Substract TK animals from the "StudyInitialWeights" and StudyBodyWeights" data frame
    #tk_less_StudyBodyWeights <- StudyBodyWeights[!(StudyBodyWeights$USUBJID %in% tK_animals_df$USUBJID),]

    tk_less_StudyBodyWeights <- StudyBodyWeights[(StudyBodyWeights$USUBJID %in% master_compiledata$USUBJID),]

    # Substract TK animals from the "StudyInitialWeights" data frame
    #tk_less_StudyInitialWeights <- StudyInitialWeights[!(StudyInitialWeights$USUBJID %in% tK_animals_df$USUBJID),]
    tk_less_StudyInitialWeights <- StudyInitialWeights[(StudyInitialWeights$USUBJID %in% master_compiledata$USUBJID),]

    # Rename columns in StudyInitialWeights by adding "_Init" suffix
    names(tk_less_StudyInitialWeights) <- ifelse(names(tk_less_StudyInitialWeights) == "USUBJID",
                                                 "USUBJID",
                                                 paste0(names(tk_less_StudyInitialWeights), "_Init"))

    #  Inner join"StudyInitialWeights" and StudyBodyWeights"
    # an inner join on the USUBJID column for TK_less (StudyInitialWeights & StudyBodyWeights )
    joined_BW_df <- merge(tk_less_StudyBodyWeights,
                          tk_less_StudyInitialWeights,
                                       by = "USUBJID")


    # Select specific columns from joined_BW_df
    BW_df_selected_column <- joined_BW_df[, c("USUBJID", "STUDYID", "BWSTRESN", "BWSTRESN_Init")]

    # Add "ARMCD","SETCD","SEX" to "selected_df"
    STUDYID_less_master_compiledata <- master_compiledata[, c("USUBJID", "ARMCD","SETCD","SEX")]
    BW_df_merged_ARMCD <- merge(BW_df_selected_column, STUDYID_less_master_compiledata, by = "USUBJID")


    # "BWzScore Calculation"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    # Create the finalbodyweight column in merged_recovery_tk_cleaned_dose_ranked_df data frame
    bwzscore_BW_df <- BW_df_merged_ARMCD %>%
      dplyr::mutate(finalbodyweight = abs(BWSTRESN - BWSTRESN_Init))

    # Create the BWZSCORE column
    bwzscore_BW <- bwzscore_BW_df %>%
      dplyr::group_by(STUDYID) %>%
      dplyr::mutate(
        mean_vehicle = mean(finalbodyweight[ARMCD == "vehicle"], na.rm = TRUE),
        sd_vehicle = stats::sd(finalbodyweight[ARMCD == "vehicle"], na.rm = TRUE)
      ) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(
        BWZSCORE = (finalbodyweight - mean_vehicle) / sd_vehicle
      ) %>%
      dplyr::select(-mean_vehicle, -sd_vehicle)  # Optionally remove the mean_vehicle and sd_vehicle columns

    # Filter and select specific columns
    HD_BWzScore <- bwzscore_BW %>%
      dplyr::filter(ARMCD == "HD") %>%
      dplyr::select(STUDYID, USUBJID, SEX, BWZSCORE)

    as.data.frame(HD_BWzScore)


  if (return_individual_scores){

    bwzscore_BW <- bwzscore_BW

    # %>%  # Calculate average, ignoring NAs
    #   dplyr::mutate(BWzScore_avg  = ifelse(BWzScore_avg  >= 3, 3,
    #                                        ifelse(BWzScore_avg  >= 2, 2,
    #                                               ifelse(BWzScore_avg  >= 1, 1, 0))))

  } else if (return_zscore_by_USUBJID ) {

    BW_zscore_by_USUBJID_HD <- bwzscore_BW %>%
      dplyr::filter(ARMCD == "HD") %>%  # Step 1: Filter for HD
      dplyr::group_by(STUDYID) %>%  # Step 2: Group by STUDYID
      dplyr::mutate(BWZSCORE = replace(BWZSCORE,
                                        is.infinite(BWZSCORE), NA)) %>%
      dplyr::mutate(BWZSCORE = abs(BWZSCORE))  %>%
      dplyr::select(STUDYID, USUBJID, SEX , BWZSCORE) %>%
      dplyr::mutate(BWZSCORE = ifelse(BWZSCORE >= 3, 3,
                                       ifelse(BWZSCORE >= 2, 2,
                                              ifelse(BWZSCORE >= 1, 1, 0))))
      # dplyr::mutate(BWZSCORE = ifelse(BWZSCORE == 5, 5,
      #                                 ifelse(BWZSCORE > 3, 3,
      #                                        ifelse(BWZSCORE == 3, 2,
      #                                               ifelse(BWZSCORE > 0, 1, 0)))))
    # x <- ifelse(mi_CompileData2[[colName]] == 5, 5,
    #             ifelse(mi_CompileData2[[colName]] > 3, 3,
    #                    ifelse(mi_CompileData2[[colName]] == 3, 2,
    #                           ifelse(mi_CompileData2[[colName]] > 0, 1, 0))))

  } else {

      # Handle case when (return_individual_scores == FALSE && return_zscore_by_USUBJID == FALSE)
      averaged_HD_BWzScore <- HD_BWzScore  %>%
      dplyr::select(STUDYID, BWZSCORE) %>%    # Select relevant columns
      dplyr::group_by(STUDYID) %>%             # Group by STUDYID
      dplyr::summarize(BWZSCORE_avg = mean(abs(BWZSCORE), na.rm = TRUE)) %>%  # Calculate average, ignoring NAs
      dplyr::mutate(BWZSCORE_avg  = ifelse(BWZSCORE_avg  >= 3, 3,
                                           ifelse(BWZSCORE_avg  >= 2, 2,
                                                  ifelse(BWZSCORE_avg  >= 1, 1, 0))))
        # dplyr::mutate(BWZSCORE_avg = ifelse(BWZSCORE_avg == 5, 5,
        #                                 ifelse(BWZSCORE_avg > 3, 3,
        #                                        ifelse(BWZSCORE_avg == 3, 2,
        #                                               ifelse(BWZSCORE_avg > 0, 1, 0)))))


  }

    # Return based on score_in_list_format
    if (return_individual_scores) {

      return(bwzscore_BW)

    } else if (return_zscore_by_USUBJID ) {

      return(BW_zscore_by_USUBJID_HD)

    } else {

    # Handle case when (return_individual_scores == FALSE && return_zscore_by_USUBJID == FALSE
     return(averaged_HD_BWzScore)

    }

}














