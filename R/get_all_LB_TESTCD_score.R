#' @title Get Laboratory Test Results (LB) domain Z-score for all the 'TESTCD' for a given STUDYID from SQLite Database or `.xpt` Files
#'
#' @description
#' This function computes the LB Z-score for a given STUDYID using data stored in a specified database.
#' It offers various optional parameters to customize the output, such as whether to return individual scores or Z-scores by `USUBJID`.
#'
#' @param studyid Character. STUDYID number. Defaults to `NULL`.
#'    Required for SQLite databases (`use_xpt_file = FALSE`).
#'    Must be `NULL` for `.xpt` files (`use_xpt_file = TRUE`).
#' @param path_db Character. Path to the SQLite database file or a folder containing `.xpt` files. Mandatory.
#' @param fake_study Logical. Whether the study data is generated by the `SENDsanitizer` package. Defaults to `FALSE`.
#' @param use_xpt_file Logical. Whether to retrieve study data from `.xpt` files instead of the SQLite database. Defaults to `FALSE`.
#' @param master_compiledata Optional, character \cr
#'   If `master_compiledata` is not supplied (i.e., `NULL`), the function will automatically call the `get_compile_data` function to calculate it.
#' @param return_individual_scores Optional, logical \cr
#'   If TRUE, the function returns individual scores for each domain by averaging the scores of all subjects/animals (`USUBJID`) in the study. Default is `FALSE`.
#' @param return_zscore_by_USUBJID Optional, logical \cr
#'    If `TRUE`, the function returns Z-scores for each animal/subject by `USUBJID`. Default is `FALSE`.
#'
#' @return
#' A data frame containing the LB Z-scores:
#' - If `return_individual_scores = TRUE`: Returns averaged Z-scores for each  domain per `studyid`.
#' - If `return_zscore_by_USUBJID = TRUE`: Returns Z-score for each animal/subject by `USUBJID` for each domain per `studyid`.
#' - Otherwise, a summarized BW score for the specified `studyid`.
#'
#' @examples
#' \dontrun{
#' # Example usage of the function
#' get_lb_score(studyid='1234123', path_db='path/to/database.db')
#' }
#'
#' @export

get_all_lb_TESTCD_zscore <- function(studyid = NULL,
                                     path_db,
                                     fake_study= FALSE,
                                     use_xpt_file = FALSE,
                                     master_compiledata = NULL,
                                     return_individual_scores = FALSE) {

  studyid <- as.character(studyid)
  path <- path_db

  # Helper function to fetch data from SQLite database
  fetch_domain_data <- function(db_connection, domain_name, studyid) {
    domain_name <- toupper(domain_name)
    query_statement <- paste0('SELECT * FROM ', domain_name, " WHERE STUDYID = :x")
    query_result <- DBI::dbGetQuery(db_connection, statement = query_statement, params = list(x = studyid))
    query_result
  }

  get_input_filename <- function(file_path, pattern) {
    input_filename <- list.files(file_path, pattern = pattern, ignore.case = TRUE)[1]
    input_filename
  }

  get_xpt_data <- function(xpt_path, pattern) {
    xpt_filename <- get_input_filename(xpt_path, pattern)
    xpt_df <- haven::read_xpt(fs::path(xpt_path, xpt_filename))
    xpt_df
  }

  get_csv_data <- function(csv_path, pattern) {
    csv_filename <- get_input_filename(csv_path, pattern)
    csv_df <- read.csv(fs::path(csv_path, csv_filename))
    empty_name_cols <- which(colnames(csv_df) == "X")
    if (length(empty_name_cols) > 0) {
      csv_df <- csv_df[, -empty_name_cols]
    } else {
      csv_df <- csv_df # No empty named columns to remove
    }
    csv_df[is.na(csv_df)] <- ''
    csv_df <- mutate(csv_df, STUDYID = as.character(STUDYID))
    csv_df
  }

  # GET THE REQUIRED DOMAIN DATA
  if (use_xpt_file) {
    # Read data from .xpt files
    lb <- get_xpt_data(path,'lb\\.xpt')
  } else {
    # Read data from .csv files
    lb <- get_csv_data(path,'lb\\.csv')
  }

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Work on the LB domain
  LB_selected_columns <-  lb[ , c("STUDYID", "DOMAIN", "USUBJID", "LBTESTCD",
                                  "LBTEST", "LBCAT", "LBORRES", "LBORRESU", "LBSTRESC", "LBSTRESN", "LBSTRESU", "LBSPEC", "VISITDY", "LBDY")]

    # convert the "LBSTRESN" column to numeric
    LB_selected_columns$LBSTRESN <- as.numeric(LB_selected_columns$LBSTRESN)

    # Remove rows with NA  values in the LBSTRESN column
    LB_selected_columns <- LB_selected_columns[!is.na(LB_selected_columns$LBSTRESN),]

    # Remove rows with  "o" values in the LBSTRESN column
    LB_selected_columns <- LB_selected_columns[!(LB_selected_columns$LBSTRESN) == 0,]

    #Make LB Data Data Frame to Hold Information
    LBData <- data.frame("STUDYID" = NA,"USUBJID" = NA,"LBSPEC" = NA,"LBTESTCD" = NA,
                         "LBSTRESN" = NA, "VISITDY" = NA)

    # for (Name in unique(filtered_combined_lb$STUDYID)) {
    # Filter the data for the current STUDYID
    #study_data_LB <- lb
    study_data_LB <- LB_selected_columns

    # Check if LBDY column exists and process accordingly
    if ("LBDY" %in% names(study_data_LB)) {
      LBD <- study_data_LB %>%
        dplyr::filter(LBDY >= 1) %>%
        dplyr::select(STUDYID,USUBJID, LBSPEC, LBTESTCD, LBSTRESN, LBDY)

      colnames(LBD) <- c("STUDYID", "USUBJID", "LBSPEC", "LBTESTCD", "LBSTRESN", "VISITDY")

      # Convert LBCAT to LBSPEC if LBSPEC is NA
      if (all(is.na(LBD$LBSPEC))) {
        LBD$LBSPEC <- study_data_LB$LBCAT[study_data_LB$LBDY >= 1]

        if (any(c("HEMATOLOGY", "Hematology","hematology") %in% levels(LBD$LBSPEC))){
          levels(LBD$LBSPEC)[match(c("HEMATOLOGY", "Hematology","hematology"),
                                   levels(LBD$LBSPEC))] <- "WHOLE BLOOD"
        }
        if (any(c("CLINICAL CHEMISTRY","Clinical Chemistry") %in% levels(LBD$LBSPEC))){
          levels(LBD$LBSPEC)[match(c("CLINICAL CHEMISTRY","Clinical Chemistry"),
                                   levels(LBD$LBSPEC))] <- "SERUM"
        }
        if (any(c("URINALYSIS","Urinalysis") %in% levels(LBD$LBSPEC))){
          levels(LBD$LBSPEC)[match(c("URINALYSIS","Urinalysis"),
                                   levels(LBD$LBSPEC))] <- "URINE"
        }
      }
    } else {
      # If LBDY column does not exist, handle accordingly
      LBD <- study_data_LB[which(study_data_LB$VISITDY >= 1),
                           c("STUDYID","USUBJID","LBSPEC","LBTESTCD","LBSTRESN", "VISITDY")]
    }

    # Add to LBData
    LBData <- rbind(LBData, LBD)

    # Remove rows with all NAs
    LBData <- stats::na.omit(LBData)

    # Concatenate LBSPEC and LBTESTCD
    #LBData$LBTESTCD <- paste(LBData$LBSPEC, LBData$LBTESTCD, sep = ' | ')

    #Remove Not Included Tests...............................................................
    # This step remove not rows matching test from ogransystem
    #test_cleaned_LBData <- LBData[LBData$LBTESTCD %in% organTESTCDlist[['LIVER']],]

    test_cleaned_LBData <-  LBData

    # Create a new data frame with the row having the max VISITDY for each USUBJID and LBTESTCD combination
    max_visitdy_df <- test_cleaned_LBData %>%
      dplyr::group_by(USUBJID, LBTESTCD) %>%
      dplyr::filter(VISITDY == max(VISITDY, na.rm = TRUE)) %>%
      dplyr::ungroup()

    #<><><><><>... Remove TK animals and Recovery animals......<><><><><><>.
    #<><> master_compiledata is free of TK animals and Recovery animals<><><>


    if (is.null(master_compiledata)) {

      studyid <- if (use_xpt_file) NULL else studyid

      master_compiledata <- get_compile_data(studyid = studyid,
                                             path_db = path_db,
                                             fake_study = fake_study,
                                             use_xpt_file = use_xpt_file)
    }

    # Filtering the tk animals and the recovery animals
    # Remove the TK animals and Recovery animals
    LB_tk_recovery_filtered <- max_visitdy_df %>%
      dplyr::filter(USUBJID %in% master_compiledata$USUBJID)

    # Perform a left join to match USUBJID and get ARMCD ## 020924
    #-inner_join() used instead of left_join()#199
    LB_tk_recovery_filtered_ARMCD <- LB_tk_recovery_filtered %>%
      dplyr::inner_join(master_compiledata %>% dplyr::select(USUBJID, ARMCD), by = "USUBJID")


    lbtestcd_list <- unique(LB_tk_recovery_filtered_ARMCD$LBTESTCD)

    # Initialize an empty data frame for the final results
    final_results <- NULL

    # "zScore Calculation" for LB data
    # First subset the LB_tk_recovery_filtered_ARMCD data frame

    # .................Filtering data for each unique "LBTESTCD" value........

    for (lbtestcd in lbtestcd_list) {

    current_lbtestcd_df <- LB_tk_recovery_filtered_ARMCD %>%
      dplyr::filter(LBTESTCD == lbtestcd)

    # calculate the zscore for the current LBTESTCD
    zscore_df <- current_lbtestcd_df %>%
      dplyr::group_by(STUDYID) %>%
      dplyr::mutate(
        mean_vehicle = mean(LBSTRESN[ARMCD == "vehicle"], na.rm = TRUE),
        sd_vehicle = stats::sd(LBSTRESN[ARMCD == "vehicle"], na.rm = TRUE)
      ) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(
        zscore = (LBSTRESN - mean_vehicle) / sd_vehicle)%>%
      dplyr::mutate(zscore = abs(zscore))

    # Average z-score per STUDYID for all subjects with the current LBTESTCD'
    final_zscore <- zscore_df %>%
      dplyr::filter(ARMCD == "HD") %>%  # Step 1: Filter for HD
      dplyr::group_by(STUDYID) %>%  # Step 2: Group by STUDYID
      dplyr::summarise(
        avg_zscore = mean(zscore, na.rm = TRUE),  # Step 3: Average alt_zscore
        LBTESTCD = dplyr::first(LBTESTCD)) %>% # Include LBTESTCD in the summarized data
      dplyr::select (STUDYID, avg_zscore )%>% #select (avg_alt_zscore ) %>%
      dplyr::mutate(avg_zscore = ifelse(avg_zscore >= 3, 3,
                                            ifelse(avg_zscore >= 2, 2,
                                                   ifelse(avg_zscore >= 1, 1, 0))))
    # Dynamically rename the avg_zscore column to aveg_lbtestcd
    final_zscore_current <- final_zscore %>%
      dplyr::rename(!!glue::glue("avg_{lbtestcd}") := avg_zscore) %>%
      dplyr::select(STUDYID, !!glue::glue("avg_{lbtestcd}"))

    print(final_zscore_current)
    #cat ("final_zscore_current:",final_zscore_current, "\n" )

    # If final_results is NULL (first iteration), set it to final_zscore
    if (is.null(final_results)) {
      final_results <- final_zscore_current
    } else {
      # Otherwise, join with the existing final_results
      final_results <- dplyr::full_join(final_results, final_zscore_current, by = "STUDYID")
    }
 }

 # output is : final_results

print(final_results)

    if (return_individual_scores) {

      LB_all_TESTCD_zscore <- final_results


    } else {
      # Calculate the average for all the LBTESTCD, ignoring NA values
      LB_all_TESTCD_zscore <- final_results

      selected_cols <-  colnames(LB_all_TESTCD_zscore) [2:ncol(LB_all_TESTCD_zscore)]

      LB_all_TESTCD_zscore$avg_all_LBTESTCD_zscores <- rowMeans(LB_all_TESTCD_zscore[selected_cols], na.rm = TRUE)

      # select the specific columns for calculation
      LB_all_TESTCD_zscore_averaged <- LB_all_TESTCD_zscore %>% dplyr::select (STUDYID, avg_all_LBTESTCD_zscores)

      # Assigning the new variables
      #LB_final_score <- LB_all_liver_zscore_averaged

      # Create "LB_df" for FOUR_Liver_Score
      #averaged_LB_all_TESTCD_zscore  <- LB_final_score %>% dplyr::rename(LB_score_avg = avg_all_LB_zscores)

    }


  if (return_individual_scores) {
  return(LB_all_TESTCD_zscore )
 } else {
   return(LB_all_TESTCD_zscore_averaged)
 }

}
