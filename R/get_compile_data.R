#' @title Retrieve and Compile Study Data from SQLite Database or `.xpt` Files
#' @description Retrieves, cleans, and compiles data for a specified STUDYID
#'   from either a SQLite database or `.xpt` files in a given folder.
#' @param studyid Character. STUDYID number. Defaults to `NULL`.
#'    Required for SQLite databases (`use_xpt_file = FALSE`).
#'    Must be `NULL` for `.xpt` files (`use_xpt_file = TRUE`).
#' @param path_db Character. Path to the SQLite database file or a folder containing `.xpt` files. Mandatory.
#' @param fake_study Logical. Whether the study data is generated by the `SENDsanitizer` package. Defaults to `FALSE`.
#' @param use_xpt_file Logical. Whether to retrieve study data from `.xpt` files instead of the SQLite database. Defaults to `FALSE`.
##' @return A data frame containing the following columns:
#' \itemize{
#'   \item \code{STUDYID} - Study identifier.
#'   \item \code{USUBJID} - Unique subject identifier.
#'   \item \code{Species} - Species of the test subject.
#'   \item \code{SEX} - Sex of the test subject.
#'   \item \code{ARMCD} - Code representing specific Trial Arm (e.g., Low Dose, Mid Dose).
#'   \item \code{SETCD} - Code representing distinct "groups" or "trial sets".
#' }
#'
#' @examples
#' \dontrun{
#' # Retrieve data for a specific study ID from the database
#' get_compile_data(studyid = '1234123',
#'                  path_db = 'path/to/database.db',
#'                  fake_study = FALSE,
#'                  use_xpt_file = FALSE)
#'
#' # Retrieve data from all XPT files in a folder
#' get_compile_data(studyid = NULL,
#'                  path_db = 'path/to/folder',
#'                  fake_study = FALSE,
#'                  use_xpt_file = TRUE)
#' }
#' @export
#'
#' @importFrom magrittr %>%

get_compile_data <- function(studyid = NULL,
                             path_db,
                             fake_study = FALSE,
                             use_xpt_file = FALSE) {

  studyid <- as.character(studyid)
  path <- path_db

  # Define a function to query the database by domain
  fetch_domain_data <- function(db_connection, domain_name, studyid) {
    domain_name <- toupper(domain_name)
    query_statement <- paste0('SELECT * FROM ', domain_name, " WHERE STUDYID = :x")
    query_result <- DBI::dbGetQuery(db_connection, statement = query_statement, params = list(x = studyid))
    query_result
  }

  if(fake_study == TRUE && use_xpt_file == FALSE){

    # get the required domain
    dm <- read.csv(fs::path(path,'dm.csv'))[,-1]
    dm[is.na(dm)] <- ''
    dm <- mutate(dm, STUDYID = as.character(STUDYID))

    ts <- read.csv(fs::path(path,'ts.csv'))[,-1]
    ts[is.na(ts)] <- ''
    ts <- mutate(ts, STUDYID = as.character(STUDYID))

    # Convert 'dm' object to data.table
    data.table::setDT(dm)

    # Convert 'ts' object to data.table
    data.table::setDT(ts)

  # Fetch species value from ts table where TSPARMCD equals 'SPECIES
  species <- ts$TSVAL[which(ts$TSPARMCD=='SPECIES')]

  # Select specific columns from dm
  dm <- dm[,c('STUDYID','USUBJID','SEX','ARMCD','ARM','SETCD')]

  dm$Species <- species

  # Assuming dm is already defined as a data frame or tibble
  dm <- dm %>%
  dplyr::select(-ARMCD) %>%  # Remove  ARMCD
  dplyr::rename(ARMCD = ARM)  %>%   # Rename ARM to ARMCD (if ARMCD is needed)
  dplyr::select("STUDYID", "USUBJID", "Species","SEX", "ARMCD","SETCD")

  #  Update 'ARMCD' to 'vehicle' where it originally equals 'Control'
  dm <- dm %>%
    dplyr::mutate(ARMCD = dplyr::if_else(ARMCD == 'Control', 'vehicle', ARMCD))

  # Filter 'dm' to include only rows where 'ARMCD' is either 'vehicle' or 'HD'
  dm <- dm %>%
    dplyr::filter( ARMCD %in% c("vehicle", "HD"))

  data.table::setDF(dm)
  return(dm)

  } else if (fake_study == TRUE && use_xpt_file == TRUE) {
  # get the required domain
    dm <- haven::read_xpt(fs::path(path,'dm.xpt'))
    print("DEBUG xpt dm: ")
    dm
    ts <- haven::read_xpt(fs::path(path,'ts.xpt'))

    # Convert 'dm' object to data.table
    data.table::setDT(dm)

    # Convert 'dm' object to data.table
    data.table::setDT(ts)

    # Fetch species value from ts table where TSPARMCD equals 'SPECIES
    species <- ts$TSVAL[which(ts$TSPARMCD=='SPECIES')]

    # Select specific columns from dm
    #dm <- dm[,c('STUDYID','USUBJID','SPECIES','SEX','ARMCD','ARM','SETCD')]
    dm <- dm[,c('STUDYID','USUBJID','SEX','ARMCD','ARM','SETCD')]

    dm$Species <- species

    # Assuming dm is already defined as a data frame or tibble
    # dm <- dm %>%
    #   dplyr::mutate(Species = SPECIES) %>%   # Add or update the Species column
    #   dplyr::select(-SPECIES, -ARMCD) %>%  # Remove  ARMCD
    #   dplyr::rename(ARMCD = ARM)  %>%   # Rename ARM to ARMCD (if ARMCD is needed)
    #   dplyr::select("STUDYID", "USUBJID", "Species","SEX", "ARMCD","SETCD")

    # Assuming dm is already defined as a data frame or tibble
    dm <- dm %>%
      dplyr::select(-ARMCD) %>%  # Remove  ARMCD
      dplyr::rename(ARMCD = ARM)  %>%   # Rename ARM to ARMCD (if ARMCD is needed)
      dplyr::select("STUDYID", "USUBJID", "Species","SEX", "ARMCD","SETCD")

    #  Update 'ARMCD' to 'vehicle' where it originally equals 'Control'
    dm <- dm %>%
      dplyr::mutate(ARMCD = dplyr::if_else(ARMCD == 'Control', 'vehicle', ARMCD))

    # Filter 'dm' to include only rows where 'ARMCD' is either 'vehicle' or 'HD'
    dm <- dm %>%
      dplyr::filter( ARMCD %in% c("vehicle", "HD"))

    data.table::setDF(dm)
    return(dm)

    ## {{{ IN case of FAKE DATA, dm are exported as master_compileDATa
    ## THerfore, where is the tk_animals and recover animals data }}}


  } else if(fake_study == FALSE && use_xpt_file == FALSE) {

    # get the required domain
    bw <- read.csv(fs::path(path,'bw.csv'))[,-1]
    bw[is.na(bw)] <- ''
    bw <- mutate(bw, STUDYID = as.character(STUDYID))
    dm <- read.csv(fs::path(path,'dm.csv'))[,-1]
    dm[is.na(dm)] <- ''
    dm <- mutate(dm, STUDYID = as.character(STUDYID))
    ds <- read.csv(fs::path(path,'ds.csv'))[,-1]
    ds[is.na(ds)] <- ''
    ds <- mutate(ds, STUDYID = as.character(STUDYID))
    ts <- read.csv(fs::path(path,'ts.csv'))[,-1]
    ts[is.na(ts)] <- ''
    ts <- mutate(ts, STUDYID = as.character(STUDYID))
    tx <- read.csv(fs::path(path,'tx.csv'))[,-1]
    tx[is.na(tx)] <- ''
    tx <- mutate(tx, STUDYID = as.character(STUDYID))
    pc <- read.csv(fs::path(path,'pc.csv'))[,-1]
    pc[is.na(pc)] <- ''
    pc <- mutate(pc, STUDYID = as.character(STUDYID))
    # pp <- read.csv(fs::path(path,'pp.csv'))[,-1]
    # pp[is.na(pp)] <- ''
    # pp <- mutate(pp, STUDYID = as.character(STUDYID))
    # pooldef <- read.csv(fs::path(path,'pooldef.csv'))[,-1]
    # pooldef[is.na(pooldef)] <- ''
    # pooldef <- mutate(pooldef, STUDYID = as.character(STUDYID))


  } else if (fake_study == FALSE && use_xpt_file == TRUE) {

    # get the required domain
    bw <- haven::read_xpt(fs::path(path,'bw.xpt'))
    dm <- haven::read_xpt(fs::path(path,'dm.xpt'))
    ds <- haven::read_xpt(fs::path(path,'ds.xpt'))
    ts <- haven::read_xpt(fs::path(path,'ts.xpt'))
    tx <- haven::read_xpt(fs::path(path,'tx.xpt'))
    pc <- haven::read_xpt(fs::path(path,'pc.xpt'))
    # pp <- haven::read_xpt(fs::path(path,'pp.xpt'))
    # pooldef <- haven::read_xpt(fs::path(path,'pooldef.xpt'))

  }

  # Print the dimension of the data frames
  print("*********************************************************************************************************")
  print("--------------------------------------------------------------------------------------------------------")
  print("*********************************************************************************************************")

  cat("The dimension of '.....bw...data...frame ......' is:----", dim(bw)[1], "rows and", dim(bw)[2], "columns.\n")
  cat("The dimension of '.....dm...data...frame ......' is:----", dim(dm)[1], "rows and", dim(dm)[2], "columns.\n")
  cat("The dimension of '.....ds...data...frame ......' is:----", dim(ds)[1], "rows and", dim(ds)[2], "columns.\n")
  cat("The dimension of '.....ts...data...frame ......' is:----", dim(ts)[1], "rows and", dim(ts)[2], "columns.\n")
  cat("The dimension of '.....tx...data...frame ......' is:----", dim(tx)[1], "rows and", dim(tx)[2], "columns.\n")
  cat("The dimension of '.....pc...data...frame ......' is:----", dim(pc)[1], "rows and", dim(pc)[2], "columns.\n")

  print("*********************************************************************************************************")
  print("--------------------------------------------------------------------------------------------------------")
  print("*********************************************************************************************************")


 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #..Creation of compilation data...(Compilation of DM Data).........
    # Step-1 :: # CompileData is basically the compilation of DM data
    CompileData <- data.frame(STUDYID = NA,
                              Species = NA,
                              USUBJID = NA,
                                  SEX = NA,
                                ARMCD = NA,
                                SETCD = NA)

    #Pull all of the relevant DM Data
    Species <- ts$TSVAL[which(ts$TSPARMCD == "SPECIES")]
    TRTName <- ts$TSVAL[which(ts$TSPARMCD == "TRT")] # work on this line
    Duration <-ts$TSVAL[which(ts$TSPARMCD == "DOSDUR")]

    # Convert duration to days
    if (any(grepl("W",Duration)) ==TRUE){
      days <- as.numeric(gsub("\\D","",Duration))*7
    } else if (any(grepl("M",Duration)) == TRUE){
      days <- as.numeric(gsub("\\D","",Duration))*7*30
    } else {
      days <- as.numeric(gsub("\\D","",Duration))
    }
    Duration <- paste0(days,"D")

    # Make StudyID
    STUDYID <- unique(ts$STUDYID)

    # CREATE DM DATA
    DMData <- data.frame(STUDYID = rep(STUDYID, length(dm$USUBJID)),
                         Species = rep(Species, length(dm$USUBJID)),
                         USUBJID = dm$USUBJID,
                         SEX = dm$SEX,
                         ARMCD = dm$ARMCD,
                         SETCD = dm$SETCD)

    #Add to CompileData
    CompileData <- rbind(CompileData, DMData)

    # Remove NAs from the first line
    CompileData <- stats::na.omit(CompileData)

    # Create a copy of CompileData which will not
  # changes with changing the CompileData
    CompileData_copy <- data.frame(CompileData)


   # Step-2 :: # REMOVE THE RECOVERY ANIMALS from "CompileData"...<>"Recovery
   #  animals" cleaning.. using "DS domain"

    # filter for specific "DSDECOD" values...( Keep the mentioned four ) ...
    filtered_ds <- ds %>%
      dplyr::filter(DSDECOD %in% c('TERMINAL SACRIFICE',
                                   'MORIBUND SACRIFICE',
                                   'REMOVED FROM STUDY ALIVE',
                                   'NON-MORIBUND SACRIFICE'))
    # check the unique value in "DSDECOD" column
    ## cat("Displaying unique values in ds$DSDECOD after filtering:\n")
    ## print(unique(filtered_ds$DSDECOD))


    # Filter "CompileData" to keep rows where USUBJID is in "filtered_ds"
  # meaning removing recovery animals
    recovery_cleaned_CompileData <- CompileData %>%
      dplyr::filter(USUBJID %in% filtered_ds$USUBJID)


    # Step-3 :: # REMOVE THE TK ANIMALS IF SPECIES IS RAT from the~~~~~~~~~~~
   # "recovery_cleaned_CompileData"
    # Initialize an empty data frame to store the results

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #~~~~~~~~~~~~~~pc animal is tk animal~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    tK_animals_df <- data.frame(STUDYID = character(),
                                USUBJID = character(),
                                DOMAIN = character(),
                                stringsAsFactors = FALSE)


    no_pc_studies <- data.frame(STUDYID = character(),
                                    stringsAsFactors = FALSE)

    # check for the species [# Check if the current study is a rat]
  # [{# Convert Species to lowercase for case-insensitive comparison}]

    Species_lower <- tolower(Species)

    if (Species_lower %in% c("rat", "mouse")) {
      # # Create TK individuals for "Rat"/"mouse" studies

      tk_animals_usubjid <- pc[ ,c("STUDYID", "USUBJID", "DOMAIN")]

      # Check if tk_animals_usubjid  is not empty
      if (length(tk_animals_usubjid) > 0) {

        tK_animals_df <- rbind(tK_animals_df, tk_animals_usubjid)

      } else {
        # Retrieve STUDYID for the current study
        current_study_id <- bw$STUDYID[1]

        # Add study to no_poolid_studies dataframe
        no_pc_studies <- rbind(no_pc_studies,
                                   data.frame(STUDYID = current_study_id,
                                              stringsAsFactors = FALSE))
      }

    } else {
      # Create a empty data frame named "tK_animals_df"
      tK_animals_df <- data.frame(STUDYID = character(),
                                  USUBJID = character(),
                                  DOMAIN = character(),
                                  stringsAsFactors = FALSE)
    }


    # Subtract "TK_animals_df" data from the "recovery_cleaned_CompileData"
    cleaned_CompileData <- recovery_cleaned_CompileData[
   !(recovery_cleaned_CompileData$USUBJID %in% tK_animals_df$USUBJID),]



    #Adding dose_ranking-------------------------------------------------------
    #----------------GET maximum and minimum----dose_level---------------------
    #--------------------------------------------------------------------------

    #.."vehicle" and "HD animals" selection "for"cleaned_CompileData"

    # tx table  filter by TXPARMCD
  cleaned_CompileData_filtered_tx <- tx %>%
    dplyr::filter(TXPARMCD == "TRTDOS")


    # Assign the dose level for
  # "cleaned_CompileData_filtered_tx"

    # Step 1:  Create a unified separator pattern
    clean_pattern <- ";|\\||-|/|:|,"

    # Split and expand the TXVAL column, and add row_state
  clean_tx_expanded <- cleaned_CompileData_filtered_tx %>%
    dplyr::mutate(
             is_split = stringr::str_detect(TXVAL,
                                            clean_pattern),
             TXVAL = strsplit(as.character(TXVAL),
                              clean_pattern)
           ) %>%
    tidyr::unnest(TXVAL) %>%
    dplyr::mutate(
             TXVAL = as.numeric(TXVAL),
             row_state = ifelse(is_split, "new_row", "old_row")
           ) %>%
    dplyr::select(-is_split) # Remove the is_split column


    # Initialize an empty data frame for dose_ranking
    dose_ranking <- data.frame()

    dose_ranking_prob_study <- data.frame()

    if (TRUE) {
      # Assign the input dataset 'clean_tx_expanded' to 'study_data' for processing
      study_data <- clean_tx_expanded

      # Check if all TXVAL values are NA for the STUDYID
      if (all(is.na(study_data$TXVAL))) {
        # Append the study data to 'dose_ranking_prob_study' for problematic cases
        dose_ranking_prob_study <- rbind(dose_ranking_prob_study, study_data)
      }
      # Check if all SETCD values are the same for the STUDYID
      else if (dplyr::n_distinct(study_data$SETCD) == 1) {
        # Append the study data to 'dose_ranking_prob_study' since SETCD is not diverse
        dose_ranking_prob_study <- rbind(dose_ranking_prob_study, study_data)
      } else {
        # Find and process the lowest TXVAL (dose level) when data is valid
        lowest_txval <- min(study_data$TXVAL, na.rm = TRUE) # Get the lowest TXVAL

        # Filter rows where TXVAL equals the lowest value and sort by SETCD
        lowest_data <- study_data %>%
          dplyr::filter(TXVAL == lowest_txval) %>%
          dplyr::arrange(SETCD)

        # If there is exactly one row with the lowest TXVAL, add it to 'dose_ranking'
        if (nrow(lowest_data) == 1) {
          dose_ranking <- rbind(dose_ranking, lowest_data)

        } else {
          # Handle cases with multiple rows having the lowest TXVAL
          # Prefer rows with 'old_row' state, selecting the first occurrence
          # Select the first old_row if available, else the first new_row
          selected_lowest <- dplyr::filter(lowest_data,
                                           row_state == "old_row") %>%
            dplyr::slice(1)

          # If an 'old_row' exists, add it to 'dose_ranking'
          if (nrow(selected_lowest) > 0) {
            dose_ranking <- rbind(dose_ranking, selected_lowest)

          } else {

            # If no 'old_row' exists, select the first 'new_row' instead
            selected_lowest <- dplyr::filter(lowest_data,
                                             row_state == "new_row") %>%
              dplyr::slice(1)

            # Append the selected 'new_row' to 'dose_ranking'
            dose_ranking <- rbind(dose_ranking, selected_lowest)
          }
        }

        # Process for highest TXVAL
        highest_txval <- max(study_data$TXVAL, na.rm = TRUE)
        highest_data <- study_data %>%
          dplyr::filter(TXVAL == highest_txval) %>%
          dplyr::arrange(SETCD)

        if (nrow(highest_data) == 1) {
          dose_ranking <- rbind(dose_ranking, highest_data)
        }else if (nrow(highest_data) > 1) {
          selected_highest <- dplyr::filter(highest_data,
                                            row_state == "old_row") %>%
            dplyr::slice(1)
          if (nrow(selected_highest) > 0) {
            dose_ranking <- rbind(dose_ranking, selected_highest)
          } else {
            # If no old_row is found, select the first new_row
            selected_highest <- dplyr::filter(highest_data,
                                              row_state == "new_row") %>%
              dplyr::slice(1)
            if (nrow(selected_highest) > 0) {
              dose_ranking <- rbind(dose_ranking, selected_highest)

            }
          }
        }
      }
    }

    # ADD DOSE_RANKING column in "selected_rows" data frame
    DOSE_RANKED_selected_rows <- dose_ranking %>%
      dplyr::group_by(STUDYID) %>%
      dplyr::mutate(
        MinTXVAL = min(TXVAL),
        MaxTXVAL = max(TXVAL),
        DOSE_RANKING = dplyr::case_when(
          TXVAL == MinTXVAL & TXVAL == MaxTXVAL ~ "Both",
          TXVAL == MinTXVAL ~ "vehicle",
          TXVAL == MaxTXVAL ~ "HD",
          TRUE ~ "Intermediate"
        )
      ) %>%
      dplyr::select(-MinTXVAL, -MaxTXVAL) %>%
      dplyr::ungroup()

    #Merging "DOSE_RANKED_selected_rows" and "cleaned_CompileData" data framed
    dose_rank_comp_data <- dplyr::inner_join(cleaned_CompileData,
                                             DOSE_RANKED_selected_rows,
                                             by = c("STUDYID", "SETCD"))

    # rename the Data frame
    master_compiledata1 <- dose_rank_comp_data [,c("STUDYID",
                                                   "USUBJID",
                                                   "Species",
                                                   "SEX",
                                                   "DOSE_RANKING",
                                                   "SETCD")]

      # Rename the "DOSE_RANKING" column to ARMCD
    # Rename "DOSE_RANKING" to "ARMCD" in master_compiledata
    master_compiledata <- master_compiledata1 %>%
      dplyr::rename(ARMCD = DOSE_RANKING)

  as.data.frame(master_compiledata)
  return(master_compiledata)
}

